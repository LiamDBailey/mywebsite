{
  "hash": "972dc2d7eb5ff2f5d571331efcfef9e8",
  "result": {
    "markdown": "---\ntitle: Advent of Code 2021\nauthor: Liam D. Bailey\ndate: '2021-12-06'\ndescription: \"Day 4\"\ncategories: [R]\nimage: \"\"\n---\n\n\n\n\n</br>\n\n## The Data\n\n---\n\nSee the explanation for today's challenge [here](https://adventofcode.com/2021/day/4). Most of the data we've dealt with so far has been 1 dimensional vectors, but for Day 4 we're going to start working with 3-dimensional data. We're playing BINGO!\n\n![](https://media.giphy.com/media/ummeQH0c3jdm2o3Olp/giphy.gif)\n\nThe first line of data is a vector of numbers that are called out in the bingo game. We will extract these separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Read first line of data that includes the announced numbers\nnumber_calls_chr <- readLines(\"./data/Day4.txt\", n = 1)\n\n#Covert this to a vector of integers\nnumber_calls_int <- as.integer(stringr::str_split(number_calls_chr, pattern = \",\", simplify = TRUE))\n\nnumber_calls_int\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 13 47 64 52 60 69 80 85 57  1  2  6 30 81 86 40 27 26 97 77 70 92 43 94  8\n [26] 78  3 88 93 17 55 49 32 59 51 28 33 41 83 67 11 91 53 36 96  7 34 79 98 72\n [51] 39 56 31 75 82 62 99 66 29 58  9 50 54 12 45 68  4 46 38 21 24 18 44 48 16\n [76] 61 19  0 90 35 65 37 73 20 22 89 42 23 15 87 74 10 71 25 14 76 84  5 63 95\n```\n:::\n:::\n\n\nWe then have a set of 100 bingo boards, each of which has 2 dimensions (5 rows and 5 columns). So how do we deal with this? One solution is to build a multi-dimensional array. A multi-dimensional array can be indexed just like a vector (1D) or matrix (2D), so we can easily work with and manipulate the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Read in the bingo boards as integers\nallboards <- as.integer(scan(\"./data/Day4.txt\", what = \"list\", skip = 2))\n\n#Convert into 3D matrix\nboard_array  <- array(allboards, dim = c(5, 5, length(allboards)/25))\n\n#Index the 1st and 2nd boards\nboard_array[,,1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   88   22    7   12   97\n[2,]   67   76   42   68   45\n[3,]   20   86    6   92   13\n[4,]   19   44   69   21   52\n[5,]   15   73   25   75   70\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   75   17   92   44   23\n[2,]   98   93   56    0    6\n[3,]   24   46   97   65   53\n[4,]   18   49   57   54   42\n[5,]   77   13   66   74   20\n```\n:::\n:::\n\n\nWe can return a 3-dimensional position of a given number using `which()` and the argument `arr.ind = TRUE`. This will come in handy for our challenges!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Find the location of the number 0 on the first two boards\n#It is at position 2,4 on the 2nd board\nwhich(board_array[,,1:2] == 0, arr.ind = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     dim1 dim2 dim3\n[1,]    2    4    2\n```\n:::\n:::\n\n\n</br>\n\n## The Challenges\n\n---\n\n### Challenge 1\n\n---\n\nFor the first challenge we need to determine which of our 100 boards will win first. To keep track of all the boards I'll create a corresponding 3D array of logical information (TRUE/FALSE) that records whether a number on a board has been marked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Array of logical data for all boards\nresult_array <- array(rep(FALSE, n = length(allboards)), dim = c(5, 5, length(allboards)/25))\n\n#Show array for the same 2 boards\nresult_array[,,1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n      [,1]  [,2]  [,3]  [,4]  [,5]\n[1,] FALSE FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE FALSE\n[3,] FALSE FALSE FALSE FALSE FALSE\n[4,] FALSE FALSE FALSE FALSE FALSE\n[5,] FALSE FALSE FALSE FALSE FALSE\n\n, , 2\n\n      [,1]  [,2]  [,3]  [,4]  [,5]\n[1,] FALSE FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE FALSE\n[3,] FALSE FALSE FALSE FALSE FALSE\n[4,] FALSE FALSE FALSE FALSE FALSE\n[5,] FALSE FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n\nNow we need to work through each of the called numbers and work out which board gets a full row or column first (we're ignoring diagonals here). We'll just use a for loop to run through all these numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Loop through all numbers called\nresult <- NULL\nfor (number in number_calls_int){\n\n  #Use which to find all locations where this number occurs\n  #Update results on the corresponding array of logicals.\n  result_array[which(board_array == number, arr.ind = TRUE)] <- TRUE\n\n  #Use apply to run through every board (the 3rd dimension, thus MARGIN = 3)\n  #Check if any boards have full rows or columns\n  board_status <- apply(result_array, MARGIN = 3, FUN = function(x){\n\n    any(rowSums(x) == 5) | any(colSums(x) == 5)\n\n  })\n\n  has_winner <- any(board_status)\n\n  #If there is a winner compute our answer\n  if (has_winner) {\n\n    winner <- board_array[,,board_status]\n    unmarked <- winner[!result_array[,,board_status]]\n\n    #Challenge asks for unmarked numbers * current number called\n    result <- sum(unmarked) * number\n\n    break()\n\n  }\n\n}\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 49686\n```\n:::\n:::\n\n\n### Challenge 2\n\n---\n  \nFor the second challenge, we need to find the board that will win *last*. This time around I'll practice building a recursive function again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Reset our results array\nresult_array <- array(rep(FALSE, n = length(allboards)), dim = c(5, 5, length(allboards)/25))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create recursive function.\nplay_bingo <- function(bingo_boards, numbers, i, current_results){\n\n  #Find current number being called\n  number <- numbers[i]\n\n  #Update results board with new number called.\n  current_results[which(bingo_boards == number, arr.ind = TRUE)] <- TRUE\n\n  #Check status of all boards\n  board_status <- apply(current_results, MARGIN = 3, FUN = function(x){\n\n    any(rowSums(x) == 5) | any(colSums(x) == 5)\n\n  })\n\n  #If there is only one board left and it is finished...\n  if (length(board_status) == 1 & sum(board_status) == 1) {\n\n    #Then return our answer\n    last_winner <- bingo_boards[,,1]\n    unmarked <- last_winner[!current_results[,,1]]\n\n    return(sum(unmarked) * number)\n\n  #Otherwise, remove all winning boards and call the function again...\n  } else {\n\n    #Filter only losing boards...\n    losing_boards  <- bingo_boards[,,!board_status, drop = FALSE]\n    losing_results <- current_results[,,!board_status, drop = FALSE]\n\n    #Recall function with next number\n    Recall(bingo_board = losing_boards, numbers = numbers, i = i + 1, current_results = losing_results)\n\n  }\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Let's get our result!\nplay_bingo(bingo_boards = board_array, numbers = number_calls_int, i = 1, current_results = result_array)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26878\n```\n:::\n:::\n\n\nBy using a 3D array we were able to easily work with this data. And there's no reason to stop at 3 dimensions, you can build larger multi-dimensional arrays that can be indexed and searched through in just the same way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Go crazy and build a 4D array with 2 sets of boards!\nfourD_array <- array(c(allboards, allboards), dim = c(5, 5, length(allboards)/25, 2))\n\n#Return 1st board being played in the 2nd game\nfourD_array[,,1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   88   22    7   12   97\n[2,]   67   76   42   68   45\n[3,]   20   86    6   92   13\n[4,]   19   44   69   21   52\n[5,]   15   73   25   75   70\n```\n:::\n:::\n\n\n---\n\n</br>\n\nSee previous solutions here:\n\n- [Day 1](https://www.liamdbailey.com/post/advent-of-code-2021/)\n- [Day 2](https://www.liamdbailey.com/post/advent-of-code-day-2/)\n- [Day 3](https://www.liamdbailey.com/post/advent-of-code-day-3/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}