{
  "hash": "1e66e3ac6907ce782ecda7e14a56ac2e",
  "result": {
    "markdown": "---\ntitle: Advent of Code 2021\nauthor: Liam D. Bailey\ndate: '2021-12-12'\ndescription: \"Day 7\"\ncategories: [R]\nimage: \"feature.jpg\"\nfrom: markdown+emoji\n---\n\n\n\n\n</br>\n\n## The Data\n\n---\n\nFor Day 7 we move from fish to crabs, that are supposedly using submarines :shrug:. I did not come up with the [context for this](https://adventofcode.com/2021/day/7)! Either way, we are given a vector of (1-dimensional) positions for each crab and need to identify the position where all crabs can meet that involves the *smallest* amount of movement. Technically, this challenge isn't too hard so we can spend a bit of time comparing two approaches.\n\n![](https://media.giphy.com/media/L9BR6nx99sgyQ/giphy.gif)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load data\nday7_data <- scan(file = \"./data/Day7.txt\", sep = \",\")\n\nday7_data[1:100]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1101    1   29   67 1102    0    1   65 1008   65   35   66 1005   66   28\n [16]    1   67   65   20    4    0 1001   65    1   65 1106    0    8   99   35\n [31]   67  101   99  105   32  110   39  101  115  116   32  112   97  115   32\n [46]  117  110  101   32  105  110  116   99  111  100  101   32  112  114  111\n [61]  103  114   97  109   10   14   94  153  512 1778 1219  522  207  112  148\n [76] 1185  380  530  502  957  898   71   10  719   47   51  188  188 1277  446\n [91]  156  188  990  370  549 1086   49  150   42   50\n```\n:::\n:::\n\n\n</br>\n\n## The Challenges\n\n---\n\n### Challenge 1\n\n---\n\nFor the first challenge we assume that movement costs increase linearly with distance (i.e. moving 1 positions costs 1 'energy', moving 10 positions costs 10 'energy'). We'll compare the amount of energy expended to reach locations ranging from position 0 until 1991 (the furthest position in our data):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(possible_positions <- range(day7_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]    0 1991\n```\n:::\n:::\n\n\nBecause costs of movement are linear, the amount of energy used to move to any position is just the distance covered.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenergy_use <- NULL\nfor (i in possible_positions[1]:possible_positions[2]) {\n  \n  energy_use <- append(energy_use, sum(abs(day7_data - i)))\n  \n}\n```\n:::\n\n\nWhat is the minimum amount of energy used?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(energy_use)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 351901\n```\n:::\n:::\n\n\n### Challenge 2\n\n---\n\nFor our second puzzle, we assume that energy use increases non-linearly with distance, such that the energy used is the sum of the sequence of distances traveled (i.e. moving 3 positions will use 1 + 2 + 3 = 6 energy). Luckily, there is an easy mathematical solve to determine the sum of any arithmetic sequence (i.e. a sequence that increases at a constant rate):\n\n$$S_{n} = n(a_{1} + a_{n})/2$$\n\nWhere $n$ is the length of the sequence, $a_{1}$ is the first value of the sequence, and $a_{n}$ is the last term in the sequence. We can make this into a function for easy use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Sum of values in a sequence\n#Source: https://www.varsitytutors.com/hotmath/hotmath_help/topics/sum-of-the-first-n-terms-of-an-arithmetic-sequence\nsum_seq <- function(start, end, n){\n  \n  (n*(start + end))/2\n  \n}\n```\n:::\n\n\nNow we can apply the for loop approach from before to find the minimum energy use under this non-linear energy use assumption.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenergy_use2 <- NULL\nfor (i in possible_positions[1]:possible_positions[2]) {\n  \n  diffs <- abs(day7_data - i)\n  \n  energy_use2 <- append(energy_use2, sum(sum_seq(start = 1, end = diffs, n = diffs)))\n  \n}\n\nmin(energy_use2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 101079875\n```\n:::\n:::\n\n\n### BONUS ROUND\n\n---\n\nSo this was all fairly easy it seems, but was this the most efficient method we could use? If we look at the energy use values we've calculated we can see that there is a clear 'trough' where minimum energy use is found. This is exactly the type of problem that we could solve with an optimization algorithm!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot()+\n  geom_line(aes(x = 0:1991, y = energy_use2)) +\n  #Need to subtract one to index of min energy use because R starts index at 1\n  geom_vline(xintercept = which(energy_use2 == min(energy_use2)) - 1, lty = 2) +\n  labs(x = \"Position\", y = \"Energy use\") +\n  theme_classic()\n```\n:::\n\n\n\n\n![](fig1.png)\n\nBecause we are only optimizing a single variable, we only need to use a one-dimensional optimizer. To use an optimizer, we first need to create a function that will return the value we want to minimize. This is simply a re-work of the for loop we used above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create function to optimize\noptim_func <- function(i){\n  \n  diffs <- abs(day7_data - i)\n  \n  sum(sum_seq(start = 1, end = diffs, n = diffs))\n  \n}\n```\n:::\n\n\nNow we can feed this function into the optimizer using the `optim()` function in R. There are many possible optimization algorithms that exist, but in R the 'Brent' optimizer is the default algorithm designed for one-dimensional problems.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptimal_energy <- optim(par = 1000, #Specify the value where the optimizer will start searching\n                        fn = optim_func, #Specify the function that will be used\n                        lower = 0,\n                        upper = possible_positions[2], #Specify the upper and lower values of the search space\n                        method = \"Brent\"#Specify the algorithm used\n)\n\nmin(energy_use2) == optimal_energy$value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\noptimal_energy$value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 101079758\n```\n:::\n:::\n\n\nOur optimizer returns...a smaller minimum energy use than with our previous method?! How is this possible? Well, while our challenge only considered integer distances the optimizer has no such constraint! We can see the difference between the best (continuous) position from the optimizer and the best (categorical) position from our previous method below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptimal_energy$par\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 478.484\n```\n:::\n\n```{.r .cell-code}\nwhich(energy_use2 == min(energy_use2)) - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 478\n```\n:::\n:::\n\n\nTo demonstrate how we could get the exact same result we can constrain our distances to be integers using `round()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Try doing it using an optimization algorithm\noptim_func_int <- function(i){\n  \n  diffs <- abs(day7_data - round(i))\n  \n  sum(sum_seq(start = 1, end = diffs, n = diffs))\n  \n}\n\noptimal_energy_int <- optim(par = 1000, #Specify the value where the optimizer will start searching\n                            fn = optim_func_int, #Specify the function that will be used\n                            lower = 0,\n                            upper = possible_positions[2], #Specify the upper and lower values of the search space\n                            method = \"Brent\"#Specify the algorithm used\n)\n\noptimal_energy_int$value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 101079875\n```\n:::\n:::\n\n\nSo we can now see how an optimizer could be used to solve this problem, but is it actually any better? We can do some bench marking on these methods the same way we did on [Day 1](https://www.liamdbailey.com/post/advent-of-code-2021/). In our original for loop method we necessarily have to calculate the energy use for every possible (integer) distance. In our optimization method, we only need to calculate energy use until the algorithm determines that we have reached a minima (although we cannot be certain this will be the *global* minimum).\n\nAfter benchmarking we can see that the optimization function is substantially faster than our for loop method. Orders of magnitude faster even! In our rough bootstrap below we are able to run over 1,000 times more iterations of our optimizer per second than our for loop approach. Although for loops are often useful and powerful, in cases like this an optimizer provides a much more efficient alternative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bench)\n\n#set seed so we achieve the same outcomes\nset.seed(123)\n\ntimes <- mark(old = {for (i in possible_positions[1]:2000) {\n  \n  diffs <- abs(day7_data - i)\n  \n  energy_use2 <- append(energy_use2, sum(sum_seq(start = 1, end = diffs, n = diffs)))\n  \n}},\nnew = optim(par = 1000, #Specify the value where the optimizer will start searching\n            fn = optim_func_int, #Specify the function that will be used\n            lower = 0,\n            upper = 2000, #Specify the upper and lower values of the search space\n            method = \"Brent\"#Specify the algorithm used\n), check = FALSE, iterations = 50)\n\n#How many more iterations per second does our optimizer achieve?\ntimes$`itr/sec`[2]/times$`itr/sec`[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1649.668\n```\n:::\n:::\n\n\n---\n\n</br>\n\nSee previous solutions here:\n\n- [Day 1](https://www.liamdbailey.com/post/advent-of-code-2021/)\n- [Day 2](https://www.liamdbailey.com/post/advent-of-code-day-2/)\n- [Day 3](https://www.liamdbailey.com/post/advent-of-code-day-3/)\n- [Day 4](https://www.liamdbailey.com/post/advent-of-code-day-4/)\n- [Day 5](https://www.liamdbailey.com/post/advent-of-code-day-5/)\n- [Day 6](https://www.liamdbailey.com/post/advent-of-code-day-6/)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}