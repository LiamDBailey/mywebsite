{
  "hash": "6e4b7b43d3060eb256910a69ed52add6",
  "result": {
    "markdown": "---\ntitle: Building maps using OpenStreetMap\nauthor: Liam D. Bailey\ndate: '2021-01-25'\ndescription: \"Up your map game\"\ncategories: [R]\nimage: \"featured.png\"\n---\n\n::: {.cell}\n\n:::\n\n\n## Where are the shapefiles?!\n\n---\n\nWhen I first started making maps and doing spatial analyses in R I often encountered a problem finding the data I needed. Where could I find a line showing state borders or a polygon of a nearby river? There are of course a huge number of ways to source this type of information, but for a beginner (and even sometimes as somebody more experienced) it can be difficult to keep track of all the different data sources. That's why I was so excited to find out about the `osmdata` package that allows you to query OpenStreetMap data directly in R. Access to an almost unlimited amount of spatial information from across the globe, what's not to like?!\n\nTo show off the power of OpenStreetMap data I'll build a train map of Melbourne (my home town). Here's what we'll need:\n\n- `osmdata`: For querying OpenStreetMap\n- `ggplot2`: For plotting the information we extract \n- `sf`: For working with spatial data in R\n- `dplyr`: For data wrangling\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(osmdata)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\n</br>\n\n## Creating a query\n\n---\n\nThe first step is to specify the area within which we want to search for OpenStreetMap features. We can specify the latitude and longitude limits manually, but you can also use the `getbb()` function to return the limits of a particular place (e.g. a city).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Example of a bounding box for Melbourne\n#It's often necessary to specify the greater city limit to ensure the\n#bounding box is large enough\nmelb_bb <- getbb(place_name = \"Melbourne, Australia\")\n\nmelb_bb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        min       max\nx 144.44405 146.19250\ny -38.49937 -37.40175\n```\n:::\n:::\n\n\nThen we can use the `opq()` function to start querying the OpenStreetMap API. You can build the query using pipes.\n\nThe first thing we'll want to add to the query is the type of feature we want to return with `add_osm_feature()`. There are *a lot* of possible objects we could extract from OpenStreetMap. In this case we want to find train lines and stations. The key-value pair to use is not always obvious (e.g. a cycle path is under the 'highway' key), so you may want to explore different key-value pairs [here](https://taginfo.openstreetmap.org/keys) or search for specific features on [Nominatim](https://nominatim.openstreetmap.org/ui/search.html).\n\n**TIP:** If you're querying over a large area it can be good to increase the `timeout` argument from the default 25.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Query railway lines\nmelb_query_line <- opq(bbox = melb_bb, timeout = 120) %>% \n  add_osm_feature(key = 'route', value = 'train')\n\nmelb_query_station <- opq(bbox = melb_bb, timeout = 120) %>% \n  add_osm_feature(key = 'railway', value = 'station')\n\nmelb_query_line\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$bbox\n[1] \"-38.49937,144.44405,-37.40175,146.1925\"\n\n$prefix\n[1] \"[out:xml][timeout:120];\\n(\\n\"\n\n$suffix\n[1] \");\\n(._;>;);\\nout body;\"\n\n$features\n[1] \"[\\\"route\\\"=\\\"train\\\"]\"\n\n$osm_types\n[1] \"node\"     \"way\"      \"relation\"\n\nattr(,\"class\")\n[1] \"list\"           \"overpass_query\"\nattr(,\"nodes_only\")\n[1] FALSE\n```\n:::\n:::\n\n\n</br>\n\n## Extracting some data\n\n---\n\nWe now have a query for the OpenStreetMap Overpass API...but we still need to run the query and return the spatial data! For this we can use `osmdata_sf()` to return information as sf objects (or `osmdata_sp()` if you're working with the `sp` package).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelbourne_trainline <- melb_query_line %>% \n  osmdata_sf()\n\nmelbourne_station <- melb_query_station %>% \n  osmdata_sf()\n\nmelbourne_trainline\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nObject of class 'osmdata' with:\n                 $bbox : -38.49937,144.44405,-37.40175,146.1925\n        $overpass_call : The call submitted to the overpass API\n                 $meta : metadata including timestamp and version numbers\n           $osm_points : 'sf' Simple Features Collection with 50231 points\n            $osm_lines : 'sf' Simple Features Collection with 4258 linestrings\n         $osm_polygons : 'sf' Simple Features Collection with 338 polygons\n       $osm_multilines : 'sf' Simple Features Collection with 158 multilinestrings\n    $osm_multipolygons : NULL\n```\n:::\n:::\n\n\nWe now have a whole range of objects (lines, points, and polygons), that fit our specific key-value pairs. We can already use these data to create a basic map with train lines and stations!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelbourne_trainline_lines <- melbourne_trainline$osm_lines\nmelbourne_station_points  <- melbourne_station$osm_points\n\nggplot() +\n  geom_sf(data = melbourne_trainline_lines, size = 1, colour = \"black\") +\n  geom_sf(data = melbourne_station_points, size = 1, shape = 21, colour = \"black\", fill = \"dark grey\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n</br>\n\n## Tidying up OSM data\n\n---\n\nThis doesn't look quite right! Although we queried within the greater Melbourne area, the lines and polygons can extend outside this bounding box. We can deal with this a number of ways. Here we'll use a combination of `trim_osmdata()` from within `osmdata` to clip our lines and the `coord_sf()` function to adjust the limits of plot to match the bounding box of Melbourne we've been using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelb_bb_poly <- getbb(place_name = \"Melbourne, Australia\",\n                      format_out = \"sf_polygon\") %>% \n#There are two very similar bounding boxes. We'll use the first one.\n  slice(1)\n\nmelbourne_trainline_lines <- melbourne_trainline_lines %>% \n  sf::st_filter(melb_bb_poly)\n  #Use exclude = FALSE to include lines that partially overlap our boundaries\n  # trim_osmdata(bb_poly = melb_bb_poly, exclude = FALSE)\n\nmelbourne_station_points <- melbourne_station_points %>% \n  sf::st_filter(melb_bb_poly)\n  # trim_osmdata(bb_poly = melb_bb_poly, exclude = FALSE)\n\n# melbourne_trainline_lines <- melbourne_trainline_trim$osm_lines\n# melbourne_station_points  <- melbourne_station_trim$osm_points\n\nggplot() +\n  geom_sf(data = melbourne_trainline_lines, size = 1, colour = \"black\") +\n  geom_sf(data = melbourne_station_points, size = 1, shape = 21, colour = \"black\", fill = \"dark grey\") +\n  theme_void() +\n  coord_sf(xlim = melb_bb[1, ], ylim = melb_bb[2, ])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nUsing OpenStreetMap gives us access to a huge source of spatial information, but because the data is created by a community of volunteers it can often require some cleaning. In our case, we can see there are a few stations that do not have corresponding train lines. This may occur because the train lines have been stored with a different key-value combination or are stored as a different object type, such as a polygon. For now, we will only include stations that are close (less than 1km) from a train line.\n\n**Note**: We do not use overlap because this will require points to sit exactly on the lines, which will often not occur due to things such as measurement error in the point locations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#For each station, determine the distance to all train lines\nmin_dist <- sf::st_distance(melbourne_station_points,\n                            melbourne_trainline_lines) %>% \n  #Determine the minimum distance for each station\n  apply(MARGIN = 1, FUN = min)\n\nmelbourne_station_points_subset <- melbourne_station_points %>% \n  dplyr::mutate(dist = min_dist) %>% \n  dplyr::filter(dist <= 1000)\n  \nggplot() +\n  geom_sf(data = melbourne_trainline_lines, size = 1, colour = \"black\") +\n  geom_sf(data = melbourne_station_points_subset, size = 1, shape = 21,\n          colour = \"black\", fill = \"dark grey\") +\n  theme_void() +\n  coord_sf(xlim = melb_bb[1, ], ylim = melb_bb[2, ])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n</br>\n\n## Filtering by name\n\n---\n\nWe now have a cleaned dataset of trainlines and stations within greater Melbourne, now we can work to make this map more informative by adding other features, like rivers and water bodies. We can also source this information from OpenStreetMap.\n\nWe want to add the Yarra river the bays and ocean around Melbourne to our map. Rivers can be found using the  `waterway-river` key pair, but we need to apply additional filters to make sure we don't get all rivers in Melbourne. To do this, we can apply a second filter with `add_osm_feature()` to search for objects with a specific name. By using `value_exact = FALSE` we allow for possible spelling differences in the name of the objects. Looking at [Nominatim](https://nominatim.openstreetmap.org/ui/search.html), we can see that the water bodies near Melbourne are all encompassed by the 'Bass Strait' multi-polygon (found with the `natural-strait` key pair).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbass_strait <- opq(bbox = melb_bb, timeout = 240) %>% \n  add_osm_feature(key = 'natural', value = 'strait') %>% \n  add_osm_feature(key = \"name\", value = \"Bass Strait\", value_exact = FALSE) %>%\n  osmdata_sf()\n\nbass_strait_polygon <- bass_strait$osm_multipolygons\n\nbays <- opq(bbox = melb_bb, timeout = 240) %>% \n  add_osm_feature(key = 'natural', value = 'bay') %>% \n  osmdata_sf()\n\nbays_polygon <- bays$osm_multipolygons\n\nyarra <- opq(bbox = melb_bb, timeout = 240) %>% \n  add_osm_feature(key = 'waterway', value = 'river') %>% \n  add_osm_feature(key = \"name\", value = \"Yarra River\", value_exact = FALSE) %>%\n  osmdata_sf()\n\nyarra_line <- yarra$osm_multilines\n\nggplot() +\n  geom_sf(data = bass_strait_polygon, fill = \"blue\", colour = NA) +\n  geom_sf(data = bays_polygon, fill = \"blue\", colour = NA) +\n  geom_sf(data = yarra_line, colour = \"blue\", size = 1.5) +\n  geom_sf(data = melbourne_trainline_lines, size = 1, colour = \"gray\") +\n  geom_sf(data = melbourne_station_points_subset, size = 2, shape = 21,\n          colour = \"black\", fill = \"dark grey\") +\n  theme_void() +\n  coord_sf(xlim = melb_bb[1, ], ylim = melb_bb[2, ])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n</br>\n\n## Making things pretty\n\n---\n\nWe now have the data we need to create a nice looking map of the Melbourne metro-train network. We can add some nice aesthetic touches to make it look nicer. For this we'll load some packages:\n\n- `showtext`: Adding custom fonts from Google fonts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(showtext)\n\nfont_add_google(\"Alice\", \"Alice\")\nfont_add_google(\"Ubuntu Mono\", \"Ubuntu Mono\")\n\nshowtext_auto()\n```\n:::\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = bass_strait_polygon, fill = \"#33658A\", colour = NA) +\n  geom_sf(data = bays_polygon, fill = \"#33658A\", colour = NA) +\n  geom_sf(data = yarra_line, colour = \"#33658A\", size = 1.5) +\n  geom_sf(data = melbourne_trainline_lines, size = 1.2, colour = \"gray40\") +\n  #Add a label for port phillip bay and bass strait\n  geom_text(aes(label = \"Port Phillip Bay\"), x = 144.859280, y = -38.092014,\n            family = \"Alice\", fontface = \"bold\", colour = \"grey90\") +\n  geom_text(aes(label = \"Bass Strait\"), x = 144.513047, y = -38.421423,\n            family = \"Alice\", fontface = \"bold\", colour = \"grey90\") +\n  #Add title as text inside the plot\n  geom_text(aes(label = \"- Trains of Melbourne -\"), x = 145.75, y = -37.43,\n            family = \"Alice\", size = 8,\n            colour = \"grey45\", fontface = \"bold\") +\n  geom_text(aes(label = \"Using OpenStreetMap data\"), x = 145.75, y = -37.5,\n            family = \"Alice\", size = 4,\n            colour = \"grey45\", fontface = \"bold\") +\n  labs(caption = \"Data: OSM | Plot: @ldbailey255\") +\n  coord_sf(xlim = melb_bb[1, ], ylim = melb_bb[2, ]) +\n  theme_classic() +\n  theme(panel.background = element_rect(fill = \"#f2eadf\"),\n        panel.border = element_rect(fill = NA, colour = \"grey45\", size = 1.5),\n        axis.text = element_text(family = \"Alice\", size = 14),\n        plot.caption = element_text(family = \"Ubuntu Mono\", size = 12,\n                                  colour = \"grey45\"),\n        axis.line = element_blank())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0.\nℹ Please use the `linewidth` argument instead.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}