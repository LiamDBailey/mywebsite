{
  "hash": "145871d651d3c97a2cf32c706deab013",
  "result": {
    "markdown": "---\ntitle: R 4.1.0\nauthor: Liam D. Bailey\ndate: '2021-05-20'\ndescription: \"All the newest features\"\ncategories: [R]\nimage: \"\"\n---\n\n\n\n\n# R 4.1.0\n\nIt's been talked about for awhile, but the next big changes to R, v.4.1.0, are here! For many R users, new versions don't make a huge amount of difference to their day to day work. I often find people still happpily running R v3.x! This time around, however, v4.1.0 includes some major (and interesting) changes to the base R syntax, which might affect (improve?) people's workflow. We'll cover the most talked about changes below. Put on your party hat and lets get into it.\n\n![](https://media.giphy.com/media/kyLYXonQYYfwYDIeZl/giphy.gif)\n\n</br>\n\n# The native pipe\n\n---\n\nEver since the rise of the `tidyverse` and `magrittr` I've noticed a worrying divergence in how people write R code. New users, or those that jumped on the `tidyverse` bandwagon, tended to write long piped code using `dplyr` functions. Older users, who learned R before the rise of the `tidyverse`, tended to use nested base functions to achieve the same result. Having a variety of tools to approach the same problem isn't *inherently* bad, but it seemed like we were heading towards a world where the two groups were almost using different, incomprehensible, programming languages. Enter the *native pipe*: `|>`. With v4.1.0 we now have an inbuilt pipe included in base R syntax. With `|>` you can build piped code without ever needing to load a `tidyverse` library!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#The tidyverse way\ntidy <- iris %>% \n  filter(Species == \"setosa\") %>% \n  select(Species, Sepal.Length)\n\n#The base R way\nbase <- iris[which(iris$Species == \"setosa\"), c(\"Species\", \"Sepal.Length\")]\n\n#The hybrid way\nhybrid <- iris |>\n  subset(Species == \"setosa\", select = c(\"Species\", \"Sepal.Length\"))\n\n#Same results...different inputs\nidentical(tidy, base)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(base, hybrid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThis is an awesome change for the base R syntax. I guess we can all forget about `magrittr` and move to using the native pipe, right? Well, not so fast. While the native pipe is a huge improvement, there are still a few features that might keep you using the more familiar `%>%` (at least for now).\n\n</br>\n\n### Flexible placement\n\n---\n\n`magrittr` pipe allows the left-hand side to be used at any point in the following function with the placement of the `.`. In comparison, native pipe requires the left-hand side to always fill the *first* argument on the right.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"John_Doe\", \"Jeff_Jones\", \"Rachel_Black\")\n\nnames %>% \n  gsub(pattern = \"_\", x = ., replacement = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"John Doe\"     \"Jeff Jones\"   \"Rachel Black\"\n```\n:::\n:::\n\n\nWe can achieve the same thing in base R by writing a nested function, but it's definitely not as effective and defeats some of the benefits of writing piped code (though see the [changes to anonymous functions below](#anon).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames |>\n  {function(x) gsub(pattern = \"_\", x = x, replacement = \" \")}()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"John Doe\"     \"Jeff Jones\"   \"Rachel Black\"\n```\n:::\n:::\n\n\n</br>\n\n### Short-hand pipe functions\n\n---\n\nA less well known, but sometimes useful, feature of the `magrittr` pipe is the ability to quickly turn a piece of piped code into a function. This functionality isn't available with the native pipe...although that might not be a deal breaker for many people.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create a function to run same pipe\nreplace_underscore <- . %>% \n  gsub(pattern = \"_\", x = ., replacement = \" \")\n\nreplace_underscore(names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"John Doe\"     \"Jeff Jones\"   \"Rachel Black\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#The slightly messier base approach\nreplace_underscore <- function(x){\n  \n  x |>\n    {function(x) gsub(pattern = \"_\", x = x, replacement = \" \")}()\n  \n}\n\nreplace_underscore(names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"John Doe\"     \"Jeff Jones\"   \"Rachel Black\"\n```\n:::\n:::\n\n\n</br>\n\n### The rest of the magrittr package\n\n---\n\nUntil now, we've comparing `%>%` and `|>`, but if you're actually loading the `magrittr` package there are a few other special pipes that are also powerful. One particularly useful one is the tee-pipe, `%T>%`, which allows you to create an output in the middle of your pipe (e.g. plot or view your data) without needing to stop the pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Return the sum of two normally distributed variables\ncol_sums <- data.frame(x = rnorm(10), y = rnorm(10)) %T>%\n  #View the data to make sure it all looks fine\n  print() %>%\n  #Return the column sums\n  colSums()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            x          y\n1   0.8896869 -0.2138701\n2  -2.2067168  0.1609721\n3   1.7916267 -1.5109801\n4   0.5172365  0.2260602\n5  -0.6368221  0.3274581\n6   0.3188282 -0.3949109\n7  -0.3346745 -2.1968587\n8   1.1183246 -0.8555464\n9   0.4817347  2.1802146\n10  0.4370767  0.3922608\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_sums\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        x         y \n 2.376301 -1.885200 \n```\n:::\n:::\n\n\n</br>\n\n### Dependencies\n\n---\n\nLet's not pretend that `%>%` has things all its own way. One **major** benefit of the native pipe is that it means you can use pipe with **no dependencies**. Working with the `tidyverse` can often mean working with quite a few dependencies, and there's no guarantee that updates will be backward compatible. If you're building an R package, even just for personal use, having the option of writing piped code without needing additional package dependencies might be exactly what you're looking for.\n\n![](https://media.giphy.com/media/6901DbEbbm4o0/giphy.gif)\n\n</br>\n\n<a name=\"anon\"/>\n\n# Anonymous functions\n\n---\n\nAnother major syntax change that provides base R with capabilities previously available only in the `tidyverse` are changes to how anonymous functions are written. `tidyverse` gave the possibility to quickly write anonymous functions using `~`. With v4.1.0, we can now easily create anonymous functions with the `\\(x)` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Tidy anon\niris %>% \n  group_by(Species) %>% \n  summarise(across(.fns = ~mean(., na.rm = TRUE)))\n\n#New base anon\niris %>%\n  group_by(Species) %>%\n  summarise(across(.fns = \\(x) mean(x, na.rm = TRUE)))\n```\n:::\n\n\nUnlike our pipe comparison, the new base anonymous functions have a number of benefits over `tidyverse` equivalents.\n\n</br>\n\n### Use anywhere in R\n\n---\n\nThe `~` syntax is useful within `tidyverse` but can't easily be used outside of this context. `\\(x)`, on the other hand, can be used to write functions anywhere you want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#This won't work!\n#tidy_func <- {~mean(., na.rm = TRUE)}\n#tidy_func(c(1, 4, 7))\n\n#Works fine\nbase_func <- \\(x)mean(x, na.rm = TRUE)\nbase_func(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n</br>\n\n### Multiple arguments and argument names\n\n---\n\nAnonymous functions in tidyverse allow for a single argument, but `\\(x)` allows for any number of arguments with any name you feel like!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthree_arguments <- \\(a, b, c)a*b/c\n\nthree_arguments(1.5, 4, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nSo, while I might be holding off on using native pipe, I think the new base R anonymous functions will quickly become part of my coding workflow!\n\n</br>\n\n# Concatenating factors\n\n---\n\nOne smaller change that might be useful to regular R users is the new ability to concatenate factors together. Previously, trying to concatenate different factors would coerce all levels into their underlying integers (how the data are actually stored within R). With v4.1.0, factors can be concatenated and stay as factors, combining together all the levels from the two original factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor1 <- factor(c(\"Apple\", \"Orange\", \"Apple\"), levels = c(\"Apple\", \"Orange\"))\nfactor2 <- factor(c(\"Banana\", \"Strawberry\"), levels = c(\"Banana\", \"Strawberry\"))\n\nc(factor1, factor2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Apple      Orange     Apple      Banana     Strawberry\nLevels: Apple Orange Banana Strawberry\n```\n:::\n:::\n\n\nNote that the order of the factor levels in the new factor are dependent on the order in which the two factors are concatenated together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Levels start with Apple\nc(factor1, factor2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Apple      Orange     Apple      Banana     Strawberry\nLevels: Apple Orange Banana Strawberry\n```\n:::\n\n```{.r .cell-code}\n#Levels start with Banana\nc(factor2, factor1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Banana     Strawberry Apple      Orange     Apple     \nLevels: Banana Strawberry Apple Orange\n```\n:::\n:::\n\n\n</br>\n\n# Wrap up\n\n---\n\nR v4.1.0 marks an exciting step in R development. The introduction of native pipe and easy anonymous functions will allow users to take advantage of these useful tools even if they're more comfortable in base R than the `tidyverse`. While I might not be switching over to using native pipe just yet, I'm really excited to see where this leads in future updates!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}