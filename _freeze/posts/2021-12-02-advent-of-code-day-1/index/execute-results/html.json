{
  "hash": "8662bc2e69c7308dba23a539c537b167",
  "result": {
    "markdown": "---\ntitle: Advent of Code 2021\nauthor: Liam D. Bailey\ndate: '2021-12-02'\ndescription: \"\"\ncategories: [R]\nimage: \"fig1.png\"\n---\n\n\n\n\nIt's that time of year again. Houses are lit up, presents are being bought, and Michael Bublé has emerged from his hibernation to create another album of Christmas songs. This year, in the spirit of giving, I will share my code for the 2021 [Advent of Code challenges](https://adventofcode.com/2021/about). Each day is a new small coding challenge and I'll attempt to upload and explain all my solutions! If I miss posting on any days (or you just want to look at the code in more detail) check out [my GitHub repo](https://github.com/LiamDBailey/AdventOfCode2021).\n\n![](https://media.giphy.com/media/cnhih1AM9M7z9oEQva/giphy.gif)\n\n# Day 1: Let the (Advent of Code) challenge begin!\n\n---\n\n</br>\n\n## The Data\n\n---\n\nWe are given a numeric vector containing values of ocean depth. I'll read it in as a data frame here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\nday1_data <- read_delim(file = \"./data/Day1.txt\", delim = \"/t\",\n                        col_names = \"depth\", show_col_types = FALSE)\n\nhead(day1_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  depth\n  <dbl>\n1   191\n2   185\n3   188\n4   189\n5   204\n6   213\n```\n:::\n:::\n\n\n</br>\n\n## The Challenges\n\n---\n\n</br>\n\n### Challenge 1\n\n---\n\nFor the first challenge we need to compare values along a vector and determine whether they increase or decrease. We then need to determine the number of times the depth value has increased (i.e. ocean floor became deeper). This one's pretty straight forward, as we can just use the `lead()` function from `dplyr` to compare our vector of depths to its neighbour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Each value in the vector is compared to its neighbour. Return logical to check whether depth has increased\nlogical_output <- day1_data$depth < lead(day1_data$depth)\n\n#Example output\nlogical_output[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n#Final result\nsum(logical_output, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1709\n```\n:::\n:::\n\n\n</br>\n\n### Challenge 2\n\n---\n\nFor the second challenge we need to first create a new vector using a sliding window of size 3 (the sum of each value and its next two neighbours). Then we make the same check to see how often depth has increased using this newly created vector. This isn't too much harder as we can use the `n` argument in `lead()` to return the 1st and 2nd neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create sliding window vector with window size 3\nnew_vector <- day1_data$depth + lead(day1_data$depth, n = 1) + lead(day1_data$depth, n = 2)\nsum(new_vector < lead(new_vector), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1761\n```\n:::\n:::\n\n\n</br>\n\n### BONUS ROUND!\n\n---\n\nThis works, but this type of code always feels a bit inflexible to me. What if needed to change the size of the window? We would need to re-write our definition of `new_vector` every time. What if the size of the sliding window becomes very large? The definition for `new_vector` would also become very long and difficult to follow. Is there a functional way we can deal with this?\n\nFirstly, I'll consider an approach using the tidyverse where I work in a data frame. I create a loop with `purrr` to add any number of new columns each with a different lead value. You might notice the walrus operator (`:=`) which is used in the tidyverse to create dynamic column names. I then use the package `lay` and its eponymous function to efficiently apply a function (`sum()`) across rows of a data frame. You'll need to install the `lay` package from GitHub. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#remotes::install_github(\"courtiol/lay\")\nlibrary(lay)\nlibrary(purrr)\n\n#Create a function that can take any window size\ntidy_windowfunc <- function(data, window_size = 3){\n  \n  new_vector <- data %>%\n    #Window includes the existing depth col, so we add window_size - 1 new columns\n    mutate(map_dfc(.x = (1:window_size) - 1,\n                   .f = function(i, depth){\n                     \n                     #Create a new column with lag i\n                     #Allow for dynamic col names\n                     tibble(\"depth_lag{i}\" := lead(depth, n = i))\n                     \n                   }, depth = .data$depth)) %>%\n    #Sum all the newly created lag columns using lay\n    mutate(depth_sum = lay(across(.cols = contains(\"lag\")), .fn = sum)) %>% \n    pull(depth_sum)\n  \n  sum(new_vector < lead(new_vector), na.rm = TRUE)\n  \n}\n```\n:::\n\n\nNow we can solve both puzzles using just one function!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Recreate Challenge 1\ntidy_windowfunc(data = day1_data, window_size = 1) == sum(day1_data$depth < lead(day1_data$depth), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#Recreate Challenge 2\nnew_vector <- day1_data$depth + lead(day1_data$depth, n = 1) + lead(day1_data$depth, n = 2)\ntidy_windowfunc(data = day1_data, window_size = 3) == sum(new_vector < lead(new_vector), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThis was the tidyverse way, but can we do it any better using base R? My first thought here would be to try a `while()` loop, that continues adding new neighbours until window size is reached.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create similar function with base R\nbase_windowfunc <- function(data, window_size = 3){\n  \n  i <- 1\n  depth      <- data$depth\n  new_vector <- data$depth\n  \n  #As long as we haven't reached window size, keep going!\n  while (i < window_size) {\n    \n    #Add depth data shifted by i to our existing vector.\n    #Will ensure vectors are same length (adds NAs at the end)\n    new_vector <- new_vector + depth[1:length(depth) + i]\n    i <- i + 1\n    \n  }\n  \n  sum(new_vector[1:(length(new_vector) - 1)] < new_vector[2:length(new_vector)], na.rm = TRUE)\n  \n}\n```\n:::\n\n\nThis works too and, as with most base R code, it's 100% dependency free!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Recreate Challenge 1\ntidy_windowfunc(data = day1_data, window_size = 1) == base_windowfunc(data = day1_data, window_size = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#Recreate Challenge 2\ntidy_windowfunc(data = day1_data, window_size = 3) == base_windowfunc(data = day1_data, window_size = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nSo which one is faster? I would assume that by working exclusively with vectors our base R function will be faster than our tidy function that spends some time manipulating a data frame. Is this actually the case? And if so, how much faster do we get? Let's look at the number of iterations/sec for each function and different window sizes using the `mark()` function in the `bench` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bench)\n\nbench_df <- map_df(.x = 1:20,\n                   .f = function(i){\n                     \n                     times <- mark(tidy_windowfunc(data = day1_data, window_size = i),\n                                   base_windowfunc(data = day1_data, window_size = i))\n                     \n                     data.frame(method = c(\"tidy\", \"base\"),\n                                size = i,\n                                number_per_sec = times$`itr/sec`,\n                                speed_sec = 1/times$`itr/sec`)\n                     \n                   })\n\nggplot(bench_df) +\n  geom_line(aes(x = size, y = number_per_sec, colour = method), size = 1) +\n  geom_point(aes(x = size, y = number_per_sec, colour = method), stroke = 1.5, shape = 21, fill = \"white\") +\n  scale_y_continuous(name = \"Iterations/sec\",\n                     breaks = seq(0, 15000, 5000), limits = c(0, 15000)) +\n  scale_x_continuous(name = \"Window size\") +\n  scale_colour_discrete(name = \"\") +\n  labs(title = \"Advent of Code Day 1\",\n       subtitle = \"base v. tidyverse approach\") +\n  theme_classic(base_family = \"Courier New\") +\n  theme(axis.text = element_text(colour = \"black\"),\n        legend.position = c(0.8, 0.8),\n        legend.background = element_rect(colour = \"black\"),\n        legend.title = element_blank())\n```\n:::\n\n\n\n\n![](fig1.png)\n\nAs expected, base R is more efficient, especially if we only need to work with short windows; however, this advantage decreases rapidly as we start to work with larger windows. Although it is slower, I think the tidyverse method I've used here is also very versatile, particularly if you want to return a data frame and not just a vector. Either way...they both get the correct result!\n\n*Stay tuned for days 2 - 25*\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}