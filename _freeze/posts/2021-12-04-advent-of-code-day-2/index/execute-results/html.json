{
  "hash": "6533e433eb0575d576a33b3bee14f127",
  "result": {
    "markdown": "---\ntitle: Advent of Code 2021\nauthor: Liam D. Bailey\ndate: '2021-12-04'\ndescription: \"Day 2\"\ncategories: [R]\nimage: \"\"\n---\n\n\n\n\nSee my solution for [Day 1 here](https://www.liamdbailey.com/post/advent-of-code-2021/).\n\n</br>\n\n## The Data\n\n---\n\nSee the explanation for today's challenge [here](https://adventofcode.com/2021/day/2).\n\nFor day 2, our data are a set of directions that we can use to explore the ocean floor that we mapped out on Day 1. Each row of data contains two pieces of information: the direction to move (e.g. 'forward', 'up') and the distance (an integer). We'll load the data in and then separate the direction and distance information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\n#Load data\nday2_data <- readr::read_delim(file = \"./data/Day2.txt\", delim = \" \",\n                               col_names = c(\"direction\", \"distance\"), show_col_types = FALSE)\n\nhead(day2_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 2\n  direction distance\n  <chr>        <dbl>\n1 forward          8\n2 forward          3\n3 forward          8\n4 down             6\n5 forward          3\n6 up               6\n```\n:::\n:::\n\n\n</br>\n\n## The Challenges\n\n---\n\n</br>\n\n### Challenge 1\n\n---\n\nStarting from (0,0) we need to follow each of the directions included in the data and determine our final location. We *could* simply do this using a for loop (probably the simpler solution), but I wanted to take this opportunity to practice writing [recursive functions](https://en.wikipedia.org/wiki/Recursion_(computer_science)).\n\nLet's build a function that runs through the data row by row and recalls itself each time until there is not data left. Unlike in a for loop, we don't need to define the number of iterations at the beginning, we simply define the conditions under which the function will continue. Of course...we also need to be careful not to create an infinite loop.\n\n![](https://media.giphy.com/media/3ov9jQX2Ow4bM5xxuM/giphy.gif)\n\nOur function will take a data input, a vector of start coordinates c(0,0), and three functions that will be applied to the start coordinates (this will be important for challenge 2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove <- function(data, start,\n                 forward_func,\n                 up_func,\n                 down_func){\n\n  #Separate the first line of data and the remaining data\n  input  <- data[1, ]\n  remain <- data[-1, ]\n\n  #Depending on the directions, apply a difference function\n  new_coord <- switch(input$direction,\n                      forward = forward_func(start = start, distance = input$distance),\n                      down = down_func(start = start, distance = input$distance),\n                      up = up_func(start = start, distance = input$distance))\n\n  #If there are still rows of data remaining, recall the function\n  if (nrow(remain) > 0) {\n\n    Recall(data = remain, start = new_coord,\n           forward_func = forward_func,\n           up_func = up_func,\n           down_func = down_func)\n\n  } else {\n\n    #If we've gone through all rows of data, return the coordinate\n    return(new_coord)\n\n  }\n\n}\n```\n:::\n\n\nWe'll create some very simply input functions that we can feed into our `move()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Write funcs to do each process\n#Forward moves on the x axis\nforward <- function(start, distance){\n  start[1] <- start[1] + distance\n  return(start)\n}\n\n#Up will *decrease* depth\nup <- function(start, distance){\n  start[2] <- start[2] - distance\n  return(start)\n}\n\n#Down will *increase* depth\ndown <- function(start, distance){\n  start[2] <- start[2] + distance\n  return(start)\n}\n```\n:::\n\n\nNow we can run our recursive function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_position <- move(data = day2_data, start = c(0, 0),\n                       forward_func = forward,\n                       up_func = up,\n                       down_func = down)\n\n#Return the product, which is our answer\nprod(final_position[1], final_position[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1383564\n```\n:::\n:::\n\n\n</br>\n\n### Challenge 2\n\n---\n\n[For the second challenge](https://adventofcode.com/2021/day/2), the function used for each direction type has changed. We now also need to deal with an 'aim' value that affects our forward movement. This aim value can be the third value in our start vector. Luckily, we've already written our recursive function, so this is as simple as substituting in new functions for forward, up, and down.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforward_new <- function(start, distance){\n  start[1] <- start[1] + distance\n  start[2] <- start[2] + distance*start[3]\n  return(start)\n}\n\nup_new <- function(start, distance){\n  start[3] <- start[3] - distance\n  return(start)\n}\n\ndown_new <- function(start, distance){\n  start[3] <- start[3] + distance\n  return(start)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_position <- move(data = day2_data, start = c(0, 0, 0),\n                       forward_func = forward_new, up_func = up_new, down_func = down_new)\n\n#Return the product, which is our answer\nprod(final_position[1], final_position[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1488311643\n```\n:::\n:::\n\n\nBy putting in a bit of effort to make a robust function at the beginning we were able to solve both challenges. It's a good example of how writing good functions can save you a lot of time and effort later on.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}