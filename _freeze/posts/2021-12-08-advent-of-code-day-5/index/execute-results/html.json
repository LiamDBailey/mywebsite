{
  "hash": "2863fda1a887ece6845cddb1dd27c901",
  "result": {
    "markdown": "---\ntitle: Advent of Code 2021\nauthor: Liam D. Bailey\ndate: '2021-12-08'\ndescription: \"Day 5\"\ncategories: [R]\nimage: \"\"\n---\n\n\n\n\n</br>\n\n## The Data\n\n---\n\nIt's Day 5 and we're 20% of the way through the advent challenge! See the explanation for today's challenge [here](https://adventofcode.com/2021/day/5). Today's challenges will again involve working with indexing numbers in ~~The Matrix~~ a matrix. \n\n![](https://media.giphy.com/media/uvoECTG2uCTrG/giphy.gif \"Keanu stopping some bullets\")\n\nWe're given two sets of 2-dimensional coordinates (X,Y), which represent the start and end of a line. We then need to count the number of points at which at least two lines overlap. The data includes an unusual separator (` -> `), so we'll use `read_delim()` from the `readr` package to read in the data. I find the `readr` functions more powerful than base functions for reading data because they allow for more complex separators. See the example below with base function `read.delim` that cannot use a separator larger than 1 byte.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.delim(\"./data/Day5.txt\", sep = \" -> \")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in scan(file, what = \"\", sep = sep, quote = quote, nlines = 1, quiet = TRUE, : invalid 'sep' value: must be one byte\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\n#Read in data where each set of coordinates is a character string\nraw_data <- readr::read_delim(\"./data/Day5.txt\",\n                              delim = \" -> \", col_names = c(\"start\", \"end\"),\n                              show_col_types = FALSE,\n                              col_types = list(start = readr::col_character(),\n                                               end = readr::col_character()))\n\nhead(raw_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 2\n  start   end    \n  <chr>   <chr>  \n1 503,977 843,637\n2 437,518 437,225\n3 269,250 625,250\n4 846,751 646,751\n5 18,731  402,731\n6 749,923 749,986\n```\n:::\n:::\n\n\nWe need to be able to access each of the X and Y values separately, so we'll separate this data out into 4 columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n\n#Convert the characters into a 4col numeric matrix\nstart_point <- str_split(raw_data$start, pattern = \",\", simplify = TRUE)\nend_point   <- str_split(raw_data$end, pattern = \",\", simplify = TRUE)\nall_points  <- cbind(start_point, end_point)\nall_points  <- as.numeric(all_points)\ndim(all_points) <- c(nrow(raw_data), 4)\n\nhead(all_points)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  503  977  843  637\n[2,]  437  518  437  225\n[3,]  269  250  625  250\n[4,]  846  751  646  751\n[5,]   18  731  402  731\n[6,]  749  923  749  986\n```\n:::\n:::\n\n\n</br>\n\n## The Challenges\n\n---\n\n### Challenge 1\n\n---\n\nFor challenge 1 we just focus on horizontal or vertical lines. Just like in our [bingo challenge on day 4](https://www.liamdbailey.com/post/advent-of-code-day-4/), we will create an empty matrix (all 0s) on which to map our results. Our matrix is 1000 x 1000 to accomodate all the possible coordinates in our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzero_mat <- matrix(0, nrow = 1000, ncol = 1000)\n\n#Look at a section of the matrix\nzero_mat[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    0    0    0    0    0    0    0    0    0     0\n [2,]    0    0    0    0    0    0    0    0    0     0\n [3,]    0    0    0    0    0    0    0    0    0     0\n [4,]    0    0    0    0    0    0    0    0    0     0\n [5,]    0    0    0    0    0    0    0    0    0     0\n [6,]    0    0    0    0    0    0    0    0    0     0\n [7,]    0    0    0    0    0    0    0    0    0     0\n [8,]    0    0    0    0    0    0    0    0    0     0\n [9,]    0    0    0    0    0    0    0    0    0     0\n[10,]    0    0    0    0    0    0    0    0    0     0\n```\n:::\n:::\n\n\nAs we're just focussing on the horizontal or diagonal lines, we filter only those cases where x or y are constant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Identify only horizontal or vertical lines\nnondiag <- all_points[apply(all_points, MARGIN = 1, FUN = function(x){\n\n  x[1] == x[3] | x[2] == x[4]\n\n}), ]\n```\n:::\n\n\nNow, adding lines to our matrix is fairly straight forward but we need to deal with two small issues before we do. First, the coordinates we're given start at 0,0; however, in R indexing begins at 1 (a shocking fact for people familiar with other programming languages!). This means we'll have to add 1 to all our coordinates so they can be properly used for indexing.\n\nThe second hurdle is that our coordinates are provided as X,Y, but to index a matrix in R we need to provide coordinates as Y (i.e. rows), X (i.e. columns). In the for loop below I create a sequence of coordinate to map the horizontal and vertical lines and then reverse their order to be used as our index values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:nrow(nondiag)) {\n\n  line <- nondiag[i, ]\n  \n  #Make sequence of first coordinates (X)\n  #Add one to use for R indexing\n  xs   <- (line[1]:line[3]) + 1\n  #Make sequence of second coordinates (Y)\n  ys   <- (line[2]:line[4]) + 1\n\n  #Create a matrix of index values, BUT we need to write this as Y,X instead of X,Y\n  index_values <- cbind(ys, xs)\n\n  zero_mat[index_values] <- zero_mat[index_values] + 1\n\n}\n```\n:::\n\n\nNow we can get our first answer, the number of points at which at least two lines overlap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(zero_mat > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5124\n```\n:::\n:::\n\n\n### Challenge 2\n\n---\n  \nChallenge 2 requires us to include the diagonal lines too. This might seem more complex at first, but we are given the helpful caveat that *all diagonal lines are 45 degrees*, or, in other words, the slope of all lines will be 1. Because of this, our previous approach that creates a sequence of X and Y values increasing by 1 will still be appropriate. Only this time both the X and Y values will change.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Find all diagonal lines\ndiag <- all_points[apply(all_points, MARGIN = 1, FUN = function(x){\n\n  x[1] != x[3] & x[2] != x[4]\n\n}), ]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Use the same approach to add all diagonal lines to our original matrix\nfor (i in 1:nrow(diag)) {\n\n  line <- diag[i, ]\n\n  #Make sequence of first coordinates (X)\n  #Add one to use for R indexing\n  xs   <- (line[1]:line[3]) + 1\n  #Make sequence of second coordinates (Y)\n  ys   <- (line[2]:line[4]) + 1\n\n  #Create a matrix of index values, BUT we need to write this as Y,X instead of X,Y\n  index_values <- cbind(ys, xs)\n\n  zero_mat[index_values] <- zero_mat[index_values] + 1\n\n}\n```\n:::\n\n\nOnce we have also added diagonal lines, we can get our second result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(zero_mat > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19771\n```\n:::\n:::\n\n\n---\n\n</br>\n\nSee previous solutions here:\n\n- [Day 1](https://www.liamdbailey.com/post/advent-of-code-2021/)\n- [Day 2](https://www.liamdbailey.com/post/advent-of-code-day-2/)\n- [Day 3](https://www.liamdbailey.com/post/advent-of-code-day-3/)\n- [Day 4](https://www.liamdbailey.com/post/advent-of-code-day-4/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}